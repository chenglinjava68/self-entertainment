1. reids使用的序列化协议？
  redis使用的简单通信协议，总共就5种消息体，包+ - * $ :, 
    - +表示正确 如+ok crlf 
    - -表示错误  如-error crlf
    - *表示数组 如 
      ```
        *2\r\f$3\r\f123\r\f$2\r\fab\r\f
      ```
    - :表示int数据，如：1000\r\f
    - $表示字符串，如：$3\r\f123\r\f，表示字符串，3个长度
2. redis持久化策略?
  主要分为aof和rdb两种持久化方式，aof即为往文件中追加写，默认策略是每秒写一次，数据丢失就这么来的（丢失一秒的数据），也可以通过配置集群冗余数据来进行高可用；写入rdb的时候可能是多少时间间隔内写入的数据超过多少条数据后再往rdb写，更容易丢失数据；redis重启后恢复的数据方式优先使用aof进行数据恢复，即将执行回放一次，没有aof的话就直接使用最后一次备份的快照，都没有的话就所有数据丢失，由于redis数据在内存中采用的淘汰策略默认就是allkeylru，有时候可能内存中已经被删除的数据在日志文件中还有所保留，所以需要对aof日志文件进行瘦身，redis有默认设置但是可能没有生效，需要手动执行bgrewrite来进行瘦身，即把回放日志中的操作合并，比如多次set只要最后一次的
3. redis什么时候会去删除key?
  主要分为惰性删除、定时随机删除、触发maxmemory的all key lru删除，在redis中过期的数据并不会直接从内存中移除，这就可能发现明明好多key数据已经过期了，但是key占用还是好多没有降下去；
4. redis如何实现分布式锁？
  需要考虑分布式锁的原子性，不能死锁，可重入等特性，起线程key接着persist一定时间；
5. rediscluster如何进行主从数据同步？节点数据都是怎么分布的？
  主要分为全量同步和增量同步，全量同步发生在从服务启动后第一次向主服务器拉取数据并发送sync，主服务器执行bgsave生成当前数据的快照发送并使用缓冲区记录所有在bgsave后续的aof操作，从服务器接受快照后删除本地数据，并同步所有后续的aof操作，主要同步思路还是同步aof操作，跟数据库的主从同步一样，mysql主从同步也是通过二进制日志binlog来实现的；数据主要是用过对key进行crc32校验码然后对总节点数取余生成的，将数据分散放进多个redis实例中，并且每个key值对应的数据都会有一份副本即主从，指定集群的时候就会指定主从关系，可以动态增加节点或者删除节点，这就需要自己手动reshard重分片来，否则当其中一些槽节点对应的主从都挂掉后在，整个集群因为丢失部分槽点就无法正常工作了
6. 为什么redis的数据会丢失？都发生在什么情况下？
  redis的数据都会存在内存里，通过持久策略来保证数据尽可能的不丢失，aof，rdb；在aof会丢失一秒的数据，快照可能更多；在reshard的时候所有客户端的操作数据都会丢失，主从同步的时候，从服务加入到集群中还没来得及复制主服务器的数据时，master节点挂了，此时follwer就是成为master，即便重启master后，由于他只是follower所以需要同步新master的数据而导致数据全部丢失
7. redis线程模型？为什么使用单线程不慢？
  redis主要采用单线程模型，使用io多路复用技术，当一个连接建立后绑定到redis特有的一个事件分发器上（类似于nio中的selector）然后这个selector就会监听这些线程上的事件然后把这些所有的事件都放进到一个队列里面排序处理，处理完后再返回给应答器完事；因为redis所有的操作都是在内存里，不会有太多的io延时操作，就不用新启线程切换cpu上下文反而更快，当确实需要操作一次耗时操作如save时redis是会fork一个子进程去处理这个耗时操作的